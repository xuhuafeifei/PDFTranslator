 <table><tr><td colspan="2">State</td></tr><tr><td colspan="2">Persistent state on all servers:(Updated on stable storage before responding to RPCs)</td></tr><tr><td>currentTerm</td><td>latest term server has seen (initialized to 0on first boot, increases monotonically)</td></tr><tr><td>votedFor</td><td>candidatedId that received vote in currentterm (or null if none)</td></tr><tr><td>log[]</td><td>log entries; each entry contains commandfor state machine, and term when entrywas received by leader (first index is 1)</td></tr><tr><td>Volatile state on all servers:</td><td>index of highest log entry known to becommitted (initialized to 0, increasesmonotonically)</td></tr><tr><td>commitIndex</td><td>lastApplied index of highest log entry applied to statemachine (initialized to 0, increasesmonotonically)</td></tr><tr><td>lastApplied</td><td></td></tr><tr><td>Volatile state on leaders:(Reinitialized after election)</td><td></td></tr><tr><td>nextIndex[]</td><td>for each server, index of the next log entryto send to that server (initialized to leaderlast log index + 1)</td></tr><tr><td>matchIndex[]</td><td>for each server, index of highest log entryknown to be replicated on server(initialized to 0, increases monotonically)</td></tr></table> \section*{AppendEntries RPC}

Invoked by leader to replicate log entries (\$5.3); also used as heartbeat (\$5.2).

\section*{Arguments:}

term

leaderId

prevLogIndex

prevLogTerm

entries[]

leaderCommit

Results:

term

success

Receiver implementation:

1. Reply false if term < currentTerm (\$5.1)

2. Reply false if log doesn't contain an entry at prevLogIndex whose term matches prevLogTerm (\$5.3)

3. If an existing entry conflicts with a new one (same index but different terms), delete the existing entry and all that follow it (\$5.3)

4. Append any new entries not already in the log

5. If leaderCommit $>$ commitIndex, set matchIndex $=$ $\min ($ leaderCommit, index of last new entry)

\section*{RequestVote RPC}

Invoked by candidates to gather votes (\$5.2).

\section*{Arguments:}

term

candidatedId

lastLogIndex

lastLogTerm

Results:

term

voteGranted

candidate's term

candidate requesting vote

index of candidate's last log entry (\$5.4)

term of candidate's last log entry (\$5.4)

currentTerm, for candidate to update itself true means candidate received vote

\section*{Receiver implementation:}

1. Reply false if term $<$ currentTerm (\$5.1)

2. If votedFor is null or candidatedId, and candidate's log is at least as up-to-date as receiver's log, grant vote (\$5.2, \$5.4)

\section*{Rules for Servers}

\section*{All Servers:}

- If commitIndex $>$ lastApplied: increment lastApplied, apply $\log [l a s t A p p l i e d]$ to state machine (\$5.3)

- If RPC request or response contains term $\mathrm{T}>\operatorname{currentTerm}$ : set currentTerm $=\mathrm{T}$, convert to follower (\$5.1)

\section*{Followers (\$5.2):}

- Respond to RPCs from candidates and leaders

- If election timeout elapses without receiving AppendEntries RPC from current leader or granting vote to candidate: convert to candidate

\section*{Candidates (\$5.2):}

- On conversion to candidate, start election:

- Increment currentTerm

- Vote for self

- Reset election timer

- Send RequestVote RPCs to all other servers

- If votes received from majority of servers: become leader

- If AppendEntries RPC received from new leader: convert to follower

- If election timeout elapses: start new election

\section*{Leaders:}

- Upon election: send initial empty AppendEntries RPCs (heartbeat) to each server; repeat during idle periods to prevent election timeouts (\$5.2)

- If command received from client: append entry to local log, respond after entry applied to state machine (\$5.3)

- If last log index $\geq$ nextIndex for a follower: send AppendEntries RPC with log entries starting at nextIndex

- If successful: update nextIndex and matchIndex for follower (\$5.3)

- If AppendEntries fails because of log inconsistency: decrement nextIndex and retry (\$5.3)

- If there exists an N such that $N>$ commitIndex, a majority of matchIndex[i] $\geq \mathrm{N}$, and $\log [\mathrm{N}]$. term $=$ currentTerm: set commitIndex $=N$ (\$5.3, \$5.4).

Figure 2: A condensed summary of the Raft consensus algorithm (excluding membership changes and log compaction). The server behavior in the upper-left box is described as a set of rules that trigger independently and repeatedly. Section numbers such as ยง5.2 indicate where particular features are discussed. A formal specification [31] describes the algorithm more precisely.

